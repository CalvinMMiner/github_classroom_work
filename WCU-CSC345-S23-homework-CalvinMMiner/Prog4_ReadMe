Code the following Haskell functions in a file named `Prog4.hs`. I've given you the starter code already. Complete these functions by replacing the line `error "undefined"` in them. _In your solution, you may define helper functions that are called by the original function._

If you cannot figure out one of the problems, do not remove the function, but leave it in as `error`.

**<u>In the following functions, use only recursion and standard built-in functions (and helper functions). No list comprehensions allowed.</u>** (Observe the similarity between HW3 and HW4. Do you like recursion better?)

1. Write a *recursive* function `tripleAll` that takes a list of ints, and returns a list of pairs, such that the first element in each pair is in the original number, and the second element is the original number tripled.  
   `tripleAll :: [Int] -> [(Int, Int)]`
1. Write a *recursive* function `flip'` that takes a list of pairs, and returns a list of pairs, with the pairs flipped (the first item becomes the second item, and vice versa).  
   `flip' :: [(Int, Int)] -> [(Int, Int)]`
1. Write a *recursive* function `sumLastPart` that returns the sum of the last $n$ numbers in the list, where n is the first argument to the function. (Assume that there are always at least $n$ numbers in the list. For this problem and the others, assume that no error checking is necessary unless otherwise specified. But feel free to incorporoate error checking into your definition.)  
   `sumLastPart :: Int -> [Int] -> Int`
1. Write a *recursive* function `middleProduct` that returns the product of the interior items in the list, that is, everything except the first and last item. Assume there are always at least three numbers in the list.  
   `middleProduct :: [Int] -> Int`  
1. Write a *recursive* function `init'` that has identical behavior to the `init` function. And obviously, you may not use `init`.  
   `init' :: [Int] -> [Int]`  
1. Write a *recursive* function `lowerOddLetters` that lowercases the first, third, fifth letter (and so on) of a string. Assume that the string only contains alphabet characters (no numbers or symbols).  
    `lowerOddLetters :: String -> String`
1. Write a *recursive* function `elemAt` that returns the ith item of the list, where the first item is index 1. Hint: how can you utilize multiple generators?  
   `elemAt :: Int -> [Int] -> Int`
1. Write a *recursive* function `iSort'` that uses insertion sort to sort a list of pairs `(String, Int)` where only the first element (the `Int` part of the pair) is to be considered during the sorting process.  
   `iSort' :: [(String, Int)] -> [(String, Int)]`
1. Write a *recursive* function `middleWord` that that returns the second word in a string that is composed of exactly three words. Assume that always exactly three words are present, and that words are separated by the single space character: `' '`. For example, "Haskell is fun!" should return `"is".`  (Hint: which helper functions would be useful to define?)  
   `middleWord :: String -> String`
1. Write a *recursive* function `lowerFirstLetter` that lowercases the first uppercase letter in a string. (The first uppercase letter may or may not be the initial character. If there is no uppercase letter, return the entire string unchanged.)  
   `lowerFirstLetter :: String -> String`
